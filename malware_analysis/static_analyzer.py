#!/usr/bin/env python3

import os
import magic
import yara
import hashlib
import pefile
import json
import re
from datetime import datetime
from ..utils.common import calculate_hash, get_timestamp, setup_logging

class StaticAnalyzer:
    def __init__(self, sample_path):
        self.sample_path = sample_path
        self.analysis_results = {
            'basic_info': {},
            'hashes': {},
            'strings': [],
            'pe_info': {},
            'yara_matches': [],
            'analysis_time': ''
        }
        self.logger = setup_logging('static_analysis.log')

    def analyze_basic_info(self):
        """Collect basic file information"""
        try:
            self.analysis_results['basic_info'] = {
                'file_name': os.path.basename(self.sample_path),
                'file_size': os.path.getsize(self.sample_path),
                'file_type': magic.from_file(self.sample_path),
                'mime_type': magic.from_file(self.sample_path, mime=True),
                'creation_time': datetime.fromtimestamp(
                    os.path.getctime(self.sample_path)
                ).isoformat(),
                'last_modified': datetime.fromtimestamp(
                    os.path.getmtime(self.sample_path)
                ).isoformat()
            }
            self.logger.info("Basic information collected successfully")
        except Exception as e:
            self.logger.error(f"Error collecting basic info: {str(e)}")

    def calculate_hashes(self):
        """Calculate various hashes of the sample"""
        try:
            with open(self.sample_path, 'rb') as f:
                data = f.read()
                self.analysis_results['hashes'] = {
                    'md5': hashlib.md5(data).hexdigest(),
                    'sha1': hashlib.sha1(data).hexdigest(),
                    'sha256': hashlib.sha256(data).hexdigest(),
                    'sha512': hashlib.sha512(data).hexdigest()
                }
            self.logger.info("File hashes calculated successfully")
        except Exception as e:
            self.logger.error(f"Error calculating hashes: {str(e)}")

    def extract_strings(self, min_length=8):
        """Extract ASCII and Unicode strings from the sample"""
        try:
            with open(self.sample_path, 'rb') as f:
                data = f.read()
            
            # ASCII strings
            ascii_strings = re.findall(b'[\x20-\x7E]{' + str(min_length).encode() + b',}', data)
            # Unicode strings
            unicode_strings = re.findall(b'(?:[\x20-\x7E][\x00]){' + str(min_length).encode() + b',}', data)
            
            self.analysis_results['strings'] = {
                'ascii': [s.decode('ascii') for s in ascii_strings],
                'unicode': [s.decode('utf-16le') for s in unicode_strings]
            }
            self.logger.info(f"Extracted {len(ascii_strings)} ASCII and {len(unicode_strings)} Unicode strings")
        except Exception as e:
            self.logger.error(f"Error extracting strings: {str(e)}")

    def analyze_pe(self):
        """Analyze PE file structure if the sample is a PE file"""
        try:
            pe = pefile.PE(self.sample_path)
            self.analysis_results['pe_info'] = {
                'machine_type': hex(pe.FILE_HEADER.Machine),
                'compilation_timestamp': datetime.fromtimestamp(
                    pe.FILE_HEADER.TimeDateStamp
                ).isoformat(),
                'subsystem': pe.OPTIONAL_HEADER.Subsystem,
                'dll_characteristics': pe.OPTIONAL_HEADER.DllCharacteristics,
                'sections': [],
                'imports': [],
                'exports': []
            }

            # Get sections
            for section in pe.sections:
                self.analysis_results['pe_info']['sections'].append({
                    'name': section.Name.decode().rstrip('\x00'),
                    'virtual_address': hex(section.VirtualAddress),
                    'virtual_size': hex(section.Misc_VirtualSize),
                    'raw_size': hex(section.SizeOfRawData),
                    'characteristics': hex(section.Characteristics)
                })

            # Get imports
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_imports = {
                        'dll': entry.dll.decode(),
                        'functions': []
                    }
                    for imp in entry.imports:
                        if imp.name:
                            dll_imports['functions'].append(imp.name.decode())
                    self.analysis_results['pe_info']['imports'].append(dll_imports)

            # Get exports
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    if exp.name:
                        self.analysis_results['pe_info']['exports'].append({
                            'name': exp.name.decode(),
                            'address': hex(pe.OPTIONAL_HEADER.ImageBase + exp.address)
                        })

            pe.close()
            self.logger.info("PE analysis completed successfully")
        except pefile.PEFormatError:
            self.logger.warning("File is not a valid PE file")
        except Exception as e:
            self.logger.error(f"Error analyzing PE file: {str(e)}")

    def scan_yara(self, rules_path):
        """Scan the sample with YARA rules"""
        try:
            if os.path.exists(rules_path):
                rules = yara.compile(rules_path)
                matches = rules.match(self.sample_path)
                self.analysis_results['yara_matches'] = [
                    {
                        'rule_name': match.rule,
                        'tags': match.tags,
                        'meta': match.meta
                    }
                    for match in matches
                ]
                self.logger.info(f"YARA scan completed: found {len(matches)} matches")
            else:
                self.logger.warning(f"YARA rules file not found: {rules_path}")
        except Exception as e:
            self.logger.error(f"Error during YARA scan: {str(e)}")

    def analyze(self, yara_rules_path=None):
        """Perform full analysis of the sample"""
        self.analyze_basic_info()
        self.calculate_hashes()
        self.extract_strings()
        self.analyze_pe()
        if yara_rules_path:
            self.scan_yara(yara_rules_path)
        self.analysis_results['analysis_time'] = get_timestamp()
        return self.analysis_results

    def export_results(self, output_file):
        """Export analysis results to a JSON file"""
        try:
            with open(output_file, 'w') as f:
                json.dump(self.analysis_results, f, indent=4)
            self.logger.info(f"Analysis results exported to {output_file}")
            return output_file
        except Exception as e:
            self.logger.error(f"Error exporting results: {str(e)}")
            return None

if __name__ == "__main__":
    # Example usage
    sample_path = "suspicious_file.exe"
    yara_rules = "malware_rules.yar"
    
    analyzer = StaticAnalyzer(sample_path)
    results = analyzer.analyze(yara_rules)
    analyzer.export_results("analysis_report.json") 